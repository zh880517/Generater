
<actor name="Player">
	<struct name="Base" group="player">
		<property key="base" field="CreatTime" />
		<property key="base" field="Level" owner="true"/> <!--owner为true的在生成的代码中有set的接口，不填或者false只有get接口-->
		<property key="bag" field="BuySpace"/>
		<repeat name="ItemBag" ref="bag.item" owner="true"/>
		<array name="property"/>
	</struct>
</actor>
<!--
class Player_BaseData
{
public:
private:
	uint32_t	CreatTime;
	uint32_t	Level;
	uint32_t	BuySpace;
};
class Player_ItemBagData
{
public:
private:
	uint32_t BaseID;
	uint32_t ItemNum;
};
class PlayerData
{
public:
private:
	Player_BaseData stPlayerBase;
	std::map<uint64_t, Player_ItemBagData> mItemBag;
};
-->
<actor name="Scene">
	<map name="Player" group="player">
		<property key="base" field="Level"/>
		<repeat name="ItemBag" ref="bag.item" > <!--map内部不嵌套struct结构体 map内部的数据会生成一个类, 嵌套的map使用上层的group-->
			<property field="BaseID" />
			<property field="ItemNum" />
		</repeat>
	</map><!--map类型的结构删除操作只是从内存中删除，如果要从redis中删除需要单独做接口，不生成相关代码-->
</actor>
<!--
class Scene_Player_ItemBagData
{
public:
private:
	uint32_t	BaseID;
	uint32_t	ItemNum;
};
class Scene_PlayerData
{
public:
private:
	uint32_t Level;
	std::map<uint64_t, Scene_Player_ItemBagData> mItemBag;
};
class SceneData
{
public:
private:
	std::map<uint64_t, Scene_PlayerData> mPlayer;
};
-->

<!--
repeat 类型是对 data描述文件里面的repeat的引用，其中的ref参数就是引用的repeat
map 是一个特殊的类型，是group的集合，也就是说一个map内的数据只能出现在同一个group里面，map的key就是group的key
-->